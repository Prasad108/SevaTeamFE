import { Injectable } from '@angular/core';
import { Firestore, collection, doc, getDocs, addDoc, updateDoc, deleteDoc, CollectionReference, query, where, documentId } from '@angular/fire/firestore';
import { from, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Volunteer {
  volunteerId?: string; // Auto-generated by Firestore
  name: string;
  phoneNumber: string;
  gender: string;
  pocId?: string,
  age: number;
  status: 'pending' | 'approved' | 'rejected';
  centerId: string; // Reference to centers/{centerId}

}


@Injectable({
  providedIn: 'root'
})
export class VolunteerService {
  private volunteersCollection: CollectionReference<Volunteer>;

  constructor(private firestore: Firestore) {
    this.volunteersCollection = collection(this.firestore, 'volunteers') as CollectionReference<Volunteer>;
  }

  getVolunteersByCenter(centerId: string): Observable<Volunteer[]> {
    const q = query(this.volunteersCollection, where('centerId', '==', centerId));
    return from(getDocs(q)).pipe(
      map(snapshot =>
        snapshot.docs.map(doc => {
          const data = doc.data() as Volunteer;
          return {
            ...data,
            volunteerId: doc.id  
          };
        })
      )
    );
  }

  getVolunteersByCenterWhichAreApproved(centerId: string): Observable<Volunteer[]> {
    const q = query(this.volunteersCollection, where('centerId', '==', centerId),where('status', '==', 'approved'));
    return from(getDocs(q)).pipe(
      map(snapshot =>
        snapshot.docs.map(doc => {
          const data = doc.data() as Volunteer;
          return {
            ...data,
            volunteerId: doc.id  
          };
        })
      )
    );
  }
  

  addVolunteer(volunteer: Omit<Volunteer, 'volunteerId'>): Observable<void> {
    return from(addDoc(this.volunteersCollection, volunteer)).pipe(
      map(() => {
        console.log('Volunteer added successfully');
      })
    );
  }

  updateVolunteer(volunteer: Volunteer): Observable<void> {
    if (!volunteer.volunteerId) {
      throw new Error('Volunteer ID is required for updating');
    }
    const docRef = doc(this.volunteersCollection, volunteer.volunteerId);

    // Convert the volunteer object to a plain object for Firestore update
    const updateData: Partial<Volunteer> = {
      name: volunteer.name,
      phoneNumber: volunteer.phoneNumber,
      gender: volunteer.gender,
      age: volunteer.age,
      status: volunteer.status,
      centerId: volunteer.centerId    };

    return from(updateDoc(docRef, updateData)).pipe(
      map(() => {
        console.log('Volunteer updated successfully');
      })
    );
  }

  // Delete a volunteer
  deleteVolunteer(volunteerId: string): Promise<void> {
    const docRef = doc(this.volunteersCollection, volunteerId);
    return deleteDoc(docRef);
  }

  getPendingVolunteers(): Observable<Volunteer[]> {
    const q = query(this.volunteersCollection, where('status', '==', 'pending'));
    return from(getDocs(q)).pipe(
      map(snapshot =>
        snapshot.docs.map(doc => {
          const data = doc.data() as Volunteer;
          return {
            ...data,
            volunteerId: doc.id  // Set the volunteerId here, after the spread
          };
        })
      )
    );
  }

    // Approve a volunteer by updating their status to 'approved'
    approveVolunteer(volunteerId: string): Promise<void> {
      const docRef = doc(this.volunteersCollection, volunteerId);
      return updateDoc(docRef, { status: 'approved' });
    }

    // Fetch volunteers in 'pending' state by center ID
    getPendingVolunteersByCenter(centerId: string): Observable<Volunteer[]> {
      const q = query(this.volunteersCollection, where('centerId', '==', centerId), where('status', '==', 'pending'));
      return from(getDocs(q)).pipe(
        map(snapshot =>
          snapshot.docs.map(doc => {
            const data = doc.data() as Volunteer;
            return {
              ...data,
              volunteerId: doc.id  // Set the volunteerId here, after the spread
            };
          })
        )
      );
    }

    getVolunteersByIds(volunteerIds: string[]): Observable<Volunteer[]> {
      const q = query(this.volunteersCollection, where(documentId(), 'in', volunteerIds));
      return from(getDocs(q)).pipe(
        map(snapshot =>
          snapshot.docs.map(doc => {
            const data = doc.data() as Volunteer;
            return {
              ...data,
              volunteerId: doc.id  // Set the volunteerId here, after the spread
            };
          })
        )
      );
    }
}
