import { Injectable } from '@angular/core';
import { Firestore, collection, doc, getDocs, addDoc, updateDoc, deleteDoc, CollectionReference, query, where } from '@angular/fire/firestore';
import { from, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Volunteer {
  volunteerId?: string; // Auto-generated by Firestore
  name: string;
  phoneNumber: string;
  gender: string;
  pocId: string,
  age: number;
  status: 'pending' | 'approved' | 'rejected';
  centerId: string; // Reference to centers/{centerId}

}


@Injectable({
  providedIn: 'root'
})
export class VolunteerService {
  private volunteersCollection: CollectionReference<Volunteer>;

  constructor(private firestore: Firestore) {
    this.volunteersCollection = collection(this.firestore, 'volunteers') as CollectionReference<Volunteer>;
  }

  getVolunteersByCenter(centerId: string): Observable<Volunteer[]> {
    const q = query(this.volunteersCollection, where('centerId', '==', centerId));
    return from(getDocs(q)).pipe(
      map(snapshot => snapshot.docs.map(doc => ({
        volunteerId: doc.id,
        ...doc.data()
      })))
    );
  }

  addVolunteer(volunteer: Volunteer): Observable<void> {
    return from(addDoc(this.volunteersCollection, volunteer)).pipe(
      map(() => {
        console.log('Volunteer added successfully');
      })
    );
  }

  updateVolunteer(volunteer: Volunteer): Observable<void> {
    if (!volunteer.volunteerId) {
      throw new Error('Volunteer ID is required for updating');
    }
    const docRef = doc(this.volunteersCollection, volunteer.volunteerId);

    // Convert the volunteer object to a plain object for Firestore update
    const updateData: Partial<Volunteer> = {
      name: volunteer.name,
      phoneNumber: volunteer.phoneNumber,
      gender: volunteer.gender,
      age: volunteer.age,
      status: volunteer.status,
      centerId: volunteer.centerId    };

    return from(updateDoc(docRef, updateData)).pipe(
      map(() => {
        console.log('Volunteer updated successfully');
      })
    );
  }

  deleteVolunteer(volunteerId: string): Observable<void> {
    const docRef = doc(this.volunteersCollection, volunteerId);
    return from(deleteDoc(docRef)).pipe(
      map(() => {
        console.log('Volunteer deleted successfully');
      })
    );
  }

  getPendingVolunteers(): Observable<Volunteer[]> {
    const q = query(this.volunteersCollection, where('status', '==', 'pending'));
    return from(getDocs(q)).pipe(
      map(snapshot => snapshot.docs.map(doc => ({
        volunteerId: doc.id,
        ...doc.data()
      })))
    );
  }
}
